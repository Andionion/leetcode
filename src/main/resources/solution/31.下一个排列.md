# 下一个排列

## 问题描述

这道题是 [LeetCode 31 题](https://leetcode-cn.com/problems/next-permutation/)。

“下一个排列” 的定义是：给定数字序列的字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

我们可以将该问题形式化地描述为：给定若干个数字，将其组合为一个整数。如何将这些数字重新排列，以得到下一个更大的整数。如 123 下一个更大的数为 132。如果没有更大的整数，则输出最小的整数。

以 1,2,3,4,5,6 为例，其排列依次为：

```
123456
123465
123546
...
654321
```

可以看到有这样的关系：123456 < 123465 < 123546 < ... < 654321。

## 算法推导

如何能得到这样的排列顺序呢？这是本文的重点，分析题干，下一个更大的数列，意味着两层含义：1. 是下一个排列；2. 要紧邻当前排列，不能跨排列，那么：

1. 我们希望下一个数字比**当前数字大**，这样才能符合“下一个排列”。因此只需要将**后面的大数和前面的小数交换**，就能得到一个更大的数字，比如`123456`，将`5`和`6`交换即可得到一个更大的数字`123465`
2. 我们还希望，下一个数**增加的幅度尽可能的小**，这样才能满足“紧邻当前排列”，为了满足这个要求，我们需要：
   1. 在**尽可能靠右的低位**进行交换，需要**从后往前**查找
   2. 将一个**尽可能小的“大数”**与前面的小数交换。比如`123465`，下一个排列应该是 5 和 4 进行交换，而不是 6 和 4
   3. 将大数和小数交换后，需要将该大数后面的所有数**重置为升序，升序排列后，才是最小的数字**。以`123465`举例：首先按照上一步，将`5`和`4`交换得到 `123564`；然后需要将`5`之后的数字重置为升序，得到`123546`。

## 算法过程

标准的“下一个排列”算法可以描述为：

1. **从后往前**查找第一个**相邻升序**的元素对`（i,j）`，满足`A[i] < A[j]`。此时`[j,end)`必然是降序的。
2. 在`[j,end)`**从后往前**查找第一个满足满足`A[i] < A[k]`的`k`。`A[i] `、` A[k]`就是上面说的“小数”,“大数”
3. 将`A[i] `和` A[k]`交换
4. 可以知道，此时的`[j,end)`必然是降序的，逆转`[j,end)`，使其升序
5. 如果在步骤 1 中查找不到符合的相邻元素对，说明此时的排列为降序排列，直接转至步骤 4 即可

可视化
以求 12385764 的下一个排列为例：

![image.png](https://brodychen.store/myImg/2022-02-17-113838.png)

首先从后向前查找第一个相邻升序的元素对 (i,j)。这里 i=4，j=5，对应的值为 5，7：

![image.png](https://brodychen.store/myImg/2022-02-17-113848.png)

然后在 [j,end) 从后向前查找第一个大于 A[i] 的值 A[k]。这里 A[i] 是 5，故 A[k] 是 6：

![image.png](https://brodychen.store/myImg/2022-02-17-113859.png)

将 A[i] 与 A[k] 交换。这里交换 5、6：

![image.png](https://brodychen.store/myImg/2022-02-17-113908.png)

这时 [j,end) 必然是降序，逆置 [j,end)，使其升序。这里逆置 [7,5,4]：

![image.png](https://brodychen.store/myImg/2022-02-17-113923.png)


因此，12385764 的下一个排列就是 12386457。

最后再可视化地对比一下这两个相邻的排列（橙色是蓝色的下一个排列）：

![image.png](https://brodychen.store/myImg/2022-02-17-113941.png)


